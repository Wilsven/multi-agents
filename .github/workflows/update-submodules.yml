name: Update Submodules

on:
  schedule:
    # Runs every hour (adjust as needed)
    - cron: "0 * * * *"
  workflow_dispatch: # Allows manual triggering

permissions:
  # Required to checkout the repo and push changes back
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Main Repository
        uses: actions/checkout@v4
        with:
          # We need to fetch the submodules too, but not necessarily update them yet
          submodules: "true"
          # Fetch depth 0 is needed for accurate comparison later, though potentially slower
          fetch-depth: 0
          # Use a PAT or App token if your default GITHUB_TOKEN doesn't have push rights
          # Or if you need to trigger other workflows on the push this action makes.
          # token: ${{ secrets.YOUR_PAT_OR_APP_TOKEN }}

      - name: Configure Git User
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions-bot@users.noreply.github.com"

      - name: Update Submodule References to Latest
        run: |
          echo "Updating submodules to track the latest commit on their default branch..."
          # This command checks the remote 'origin' for the branch configured for each submodule
          # (usually 'main' or 'master') and updates the main repo's index if the remote has moved.
          git submodule update --remote --init --recursive

      - name: Check for Changes, Stage ONLY Updated Submodules, Commit, and Push
        id: commit_push
        run: |
          # Get list of changed files/paths in the working tree compared to the index.
          # Updated submodules will appear here by their path.
          # Use '|| true' to prevent the command failing the step if there are no changes (git diff exits 1)
          CHANGED_SUBMODULES=$(git diff --name-only || true)

          if [ -z "$CHANGED_SUBMODULES" ]; then
            # No changes detected by git diff
            echo "No submodule updates needed (working tree is clean compared to index)."
            echo "committed=false" >> $GITHUB_OUTPUT
          else
            # Changes were detected
            echo "The following submodules appear to have been updated:"
            echo "$CHANGED_SUBMODULES" # Print the list of changed paths

            # Ensure we ONLY stage the detected submodule paths.
            # Filter CHANGED_SUBMODULES to only include expected submodule paths.
            # This prevents staging accidental non-submodule files if any existed.
            STAGED_SOMETHING=false
            echo "$CHANGED_SUBMODULES" | while IFS= read -r path; do
              # Basic check: Does the path exist in .gitmodules? A more robust check might be needed
              # if you have deeply nested submodules or complex paths.
              # This grep is simple: it checks if the path appears literally in the .gitmodules file.
              if grep -q "path = ${path}$" .gitmodules; then
                  echo "Staging updated submodule: $path"
                  git add "$path"
                  STAGED_SOMETHING=true
              else
                  echo "Skipping non-submodule or unexpected path: $path"
              fi
            done

            if [ "$STAGED_SOMETHING" = false ]; then
                echo "No actual submodule paths were staged."
                echo "committed=false" >> $GITHUB_OUTPUT
                exit 0 # Exit successfully, nothing to commit
            fi

            # Optional: Show concise status after staging
            git status --short

            echo "Committing staged submodule updates..."
            # You could potentially list the updated modules in the commit message
            # updated_list=$(echo "$CHANGED_SUBMODULES" | paste -sd "," -) # Example: api,frontend
            COMMIT_MSG="chore(submodules): Update submodule references ($(date +'%Y-%m-%d'))"
            git commit -m "$COMMIT_MSG"

            echo "Pushing changes..."
            git push origin HEAD:${{ github.ref_name }} # Push to the same branch the workflow ran on
            echo "committed=true" >> $GITHUB_OUTPUT
          fi

      - name: No Changes to Commit
        if: steps.commit_push.outputs.changed == 'false'
        run: echo "Submodules are already up-to-date with their remote branches."
